diff -u libnetmd_orig/libnetmd.c libnetmd/libnetmd.c
--- libnetmd_orig/libnetmd.c	Sun Aug  4 14:18:39 2002
+++ libnetmd/libnetmd.c	Thu Sep  5 21:23:20 2002
@@ -1,9 +1,5 @@
 #include "libnetmd.h"
 
-struct netmd_group* groups = 0;
-int group_count = 0;
-int header_length = 0;
-
 int min(int a,int b)
 {
 	if (a<b) return a;
@@ -458,7 +454,7 @@
 	return 1;
 }
 
-int get_group_count(usb_dev_handle* devh)
+int get_group_count(usb_dev_handle* devh, minidisc* md)
 {
 
 	int disc_size = 0;
@@ -470,7 +466,7 @@
 	int g = 0;
 
 	disc_size = request_disc_title(devh, disc, 256);
-	header_length = disc_size;
+	md->header_length = disc_size;
 
 	if(disc_size != 0)
 	{	
@@ -499,26 +495,26 @@
 	return (g);
 }
 
-int set_group_title(usb_dev_handle* dev, int group, char* title)
+int set_group_title(usb_dev_handle* dev, minidisc* md, int group, char* title)
 {
 	int size = strlen(title);
 
-	groups[group].name = realloc(groups[group].name, size + 1);
+	md->groups[group].name = realloc(md->groups[group].name, size + 1);
 
-	if(groups[group].name != 0)
-		strcpy(groups[group].name, title);
+	if(md->groups[group].name != 0)
+		strcpy(md->groups[group].name, title);
 	else
 		return 0;
 
-	write_disc_header(dev);
+	write_disc_header(dev, md);
 
 	return 1;
 }
 
-void set_group_data(int group, char* name, int start, int finish) {
-	groups[group].name = strdup( name );
-	groups[group].start = start;
-	groups[group].finish = finish;
+void set_group_data(minidisc* md, int group, char* name, int start, int finish) {
+	md->groups[group].name = strdup( name );
+	md->groups[group].start = start;
+	md->groups[group].finish = finish;
 	return;
 }
 
@@ -533,7 +529,7 @@
 	 *	 
 	 */
 
-int initialize_disc_info(usb_dev_handle* devh)
+int initialize_disc_info(usb_dev_handle* devh, minidisc* md)
 {
 	int disc_size = 0;
 	int track;
@@ -545,19 +541,19 @@
 	int start, finish;
 	int g = 0;
 
-	group_count = get_group_count(devh);
+	md->group_count = get_group_count(devh, md);
 
 	/* You always have at least one group, the disc title */
-	if(group_count == 0)
-		group_count++;
+	if(md->group_count == 0)
+		md->group_count++;
 
 
-	groups = malloc(sizeof(struct netmd_group) * group_count);
-	memset(groups, 0, sizeof(struct netmd_group) * group_count);
+	md->groups = malloc(sizeof(struct netmd_group) * md->group_count);
+	memset(md->groups, 0, sizeof(struct netmd_group) * md->group_count);
 	
 	disc_size = request_disc_title(devh, disc, 256);
 	printf("Raw title: %s \n", disc);
-	header_length = disc_size;
+	md->header_length = disc_size;
 
 	if(disc_size != 0)
 	{	
@@ -575,7 +571,7 @@
 					start = 0;
 					finish = 0;
 
-					set_group_data(0, name, start, finish);
+					set_group_data(md, 0, name, start, finish);
 				}
 				else
 				{
@@ -586,16 +582,16 @@
 						name = strdup("<Untitled>");
 						start = 0;
 						finish = 0;
-						set_group_data(0, name, start, finish);
+						set_group_data(md, 0, name, start, finish);
 						g++;
 						name = semicolon + 1;
-						set_group_data(g, name, start, finish);
+						set_group_data(md, g, name, start, finish);
 					}
 					else	
 					{
 						//0[-n];<title>// 
 						name = semicolon + 1;
-						set_group_data(0, name, 0, 0);
+						set_group_data(md, 0, name, 0, 0);
 					}
 				}
 			}
@@ -605,7 +601,7 @@
 					name = strdup("<Untitled>");
 					start = 0;
 					finish = 0;
-					set_group_data(0, name, start, finish);
+					set_group_data(md, 0, name, start, finish);
 					
 					g++;
 					continue;
@@ -631,7 +627,7 @@
 					printf( "Title parse error\n" );
 					return -1;
 				}
-				set_group_data(g, strdup(name), start, finish);
+				set_group_data(md, g, strdup(name), start, finish);
 			}
 			g++;
 			tok = strtok(NULL, "//");
@@ -640,12 +636,12 @@
 	return disc_size;
 }
 
-void print_groups()
+void print_groups(minidisc *md)
 {
 	int i = 0;
-	for(;i < group_count; i++)
+	for(;i < md->group_count; i++)
 	{
-		printf("Group %i: %s - %i - %i\n", i, groups[i].name, groups[i].start, groups[i].finish);
+		printf("Group %i: %s - %i - %i\n", i, md->groups[i].name, md->groups[i].start, md->groups[i].finish);
 	}
 	printf("\n");
 }
@@ -719,52 +715,52 @@
 }
 
 /* move track, then manipulate title string */
-int put_track_in_group(usb_dev_handle* dev, int track, int group)
+int put_track_in_group(usb_dev_handle* dev, minidisc *md, int track, int group)
 {
 	int i = 0;
 	int j = 0;
 	int found = 0;
 
-	printf("put_track_in_group(dev, %i, %i)\nGroup Count %i\n", track, group, group_count);
+	printf("put_track_in_group(dev, %i, %i)\nGroup Count %i\n", track, group, md->group_count);
 
-	if(group >= group_count)
+	if(group >= md->group_count)
 	{
 		return 0;
 	}
 
-	print_groups();
+	print_groups(md);
 
 	/* remove track from old group */
-	for(i = 0; i < group_count; i++)
+	for(i = 0; i < md->group_count; i++)
 	{
 		if(i == 0)
 		{
 			/* if track is before first real group */
-			if(groups[i+1].start == 0)
+			if(md->groups[i+1].start == 0)
 			{
 				/* nothing in group  */
 				found = 1;
 			}
-			if((track + 1) < groups[i+1].start)
+			if((track + 1) < md->groups[i+1].start)
 			{
 				found = 1;
-				for(j = i+1; j < group_count; j++)
+				for(j = i+1; j < md->group_count; j++)
 				{
-					groups[j].start--;
-					if(groups[j].finish != 0)
-						groups[j].finish--;
+					md->groups[j].start--;
+					if(md->groups[j].finish != 0)
+						md->groups[j].finish--;
 				}
 			}
 		}
-		else if(groups[i].start <= (track + 1) && groups[i].finish >= (track + 1))
+		else if(md->groups[i].start <= (track + 1) && md->groups[i].finish >= (track + 1))
 		{
 			found = 1;
 			/* decrement start/finish for all following groups */
-			for(j = i+1; j < group_count; j++)
+			for(j = i+1; j < md->group_count; j++)
 			{
-				groups[j].start--;
-				if(groups[j].finish != 0)
-					groups[j].finish--;
+				md->groups[j].start--;
+				if(md->groups[j].finish != 0)
+					md->groups[j].finish--;
 			}	
 		}
 	}
@@ -772,82 +768,82 @@
 	/* if track is in between groups */
 	if(!found)
 	{
-		for(i = 2; i < group_count; i++)
+		for(i = 2; i < md->group_count; i++)
 		{
-			if(groups[i].start >= (track+1) && groups[i-1].finish <= (track+1))
+			if(md->groups[i].start >= (track+1) && md->groups[i-1].finish <= (track+1))
 			{
 				found = 1;
 				/* decrement start/finish for all groups including and after this one */
-				for(j = i; j < group_count; j++)
+				for(j = i; j < md->group_count; j++)
 				{
-					groups[j].start--;
-					if(groups[j].finish != 0)
-						groups[j].finish--;
+					md->groups[j].start--;
+					if(md->groups[j].finish != 0)
+						md->groups[j].finish--;
 				}	
 			}
 		}
 	}
 
-	print_groups();
+	print_groups(md);
 
 	/* insert track into group range */
-	if(groups[group].finish != 0)
+	if(md->groups[group].finish != 0)
 	{
-		groups[group].finish++;
+		md->groups[group].finish++;
 	}
 	else
 	{
-		if(groups[group].start == 0)
-			groups[group].start = track + 1;
+		if(md->groups[group].start == 0)
+			md->groups[group].start = track + 1;
 		else
-			groups[group].finish = groups[group].start + 1;
+			md->groups[group].finish = md->groups[group].start + 1;
 	}
 	
 	/* if not last group */
-	if((group + 1) < group_count)
+	if((group + 1) < md->group_count)
 	{
 		int j = 0;
-		for(j = group + 1; j < group_count; j++)
+		for(j = group + 1; j < md->group_count; j++)
 		{
 			/* if group is NOT empty */
-			if(groups[j].start != 0 || groups[j].finish != 0)
+			if(md->groups[j].start != 0 || md->groups[j].finish != 0)
 			{
-				groups[j].start++;
-				if(groups[j].finish != 0)
+				md->groups[j].start++;
+				if(md->groups[j].finish != 0)
 				{	
-					groups[j].finish++;
+					md->groups[j].finish++;
 				}
 			}
 		}
 	}
 
 	/* what does it look like now? */
-	print_groups();
+	print_groups(md);
 
-	if(groups[group].finish != 0)
+	if(md->groups[group].finish != 0)
 	{
-	   	move_track(dev, track, groups[group].finish - 1);
+	   	move_track(dev, track, md->groups[group].finish - 1);
 	}
 	else
 	{
-		if(groups[group].start != 0)
-			move_track(dev, track, groups[group].start - 1);
+		if(md->groups[group].start != 0)
+			move_track(dev, track, md->groups[group].start - 1);
 		else
-			move_track(dev, track, groups[group].start);
+			move_track(dev, track, md->groups[group].start);
 	}
 	
-	return write_disc_header(dev);
+	return write_disc_header(dev, md);
 }
 
-int move_group(usb_dev_handle* dev, int track, int group)
+int move_group(usb_dev_handle* dev, minidisc* md, int track, int group)
 {
 	int index = 0;
 	int i = 0;
 	int gs = 0;
  	struct netmd_group store1;
 	struct netmd_group *p, *p2;
-	int gt = groups[group].start;
-	int finish = (groups[group].finish - groups[group].start) + track;
+	int gt = md->groups[group].start;
+	int finish = (md->groups[group].finish - md->groups[group].start) + track;
 	
 	p = p2 = 0;
 
@@ -861,28 +857,28 @@
 		printf("Moving track %i to %i\n", (gt - 1), index);
 		move_track(dev, (gt -1), index);
 	}
-	groups[group].start = track + 1;
-	groups[group].finish = index;
+	md->groups[group].start = track + 1;
+	md->groups[group].finish = index;
 
 	/* create a copy of groups */
-	p = malloc(sizeof(struct netmd_group) * group_count);
-	for(index = 0; index < group_count; index++)
+	p = malloc(sizeof(struct netmd_group) * md->group_count);
+	for(index = 0; index < md->group_count; index++)
 	{
-		p[index].name = malloc(strlen(groups[index].name) + 1);
-		strcpy(p[index].name, groups[index].name);
-		p[index].start = groups[index].start;
-		p[index].finish = groups[index].finish;
+		p[index].name = malloc(strlen(md->groups[index].name) + 1);
+		strcpy(p[index].name, md->groups[index].name);
+		p[index].start = md->groups[index].start;
+		p[index].finish = md->groups[index].finish;
 	}
 
 	store1 = p[group];
 	gs = store1.finish - store1.start + 1; /* how many tracks got moved? */
 
 	/* find group to bump */
-	if(track < groups[group].start)
+	if(track < md->groups[group].start)
 	{
-		for(index = 0; index < group_count; index++)
+		for(index = 0; index < md->group_count; index++)
 		{
-			if(groups[index].start > track)
+			if(md->groups[index].start > track)
 			{
 				for(i = group - 1; i >= index; i--)
 				{
@@ -900,9 +896,9 @@
 			}
 			else
 			{
-				if((group + 1) < group_count)
+				if((group + 1) < md->group_count)
 				{
-					for(i = group + 1; i < group_count; i++)
+					for(i = group + 1; i < md->group_count; i++)
 					{
 						/* all tracks get moved gs spots */
 						p[i].start -= gs;
@@ -921,47 +917,47 @@
 	}
 
 	/* free all memory, then make our copy the real info */
-	clean_disc_info();
-	groups = p;
+	clean_disc_info(md);
+	md->groups = p;
 
-	write_disc_header(dev);
+	write_disc_header(dev, md);
 	return 0;
 }
 
-int delete_group(usb_dev_handle* dev, int group)
+int delete_group(usb_dev_handle* dev, minidisc* md, int group)
 {
 	int index = 0;
 	struct netmd_group *p;
 	
 	/* check if requested group exists */
-	if((group < 0) || (group > group_count))
+	if((group < 0) || (group > md->group_count))
 		return -1;
 	
 	/* create a copy of groups below requested group */
-	p = malloc(sizeof(struct netmd_group) * group_count);
+	p = malloc(sizeof(struct netmd_group) * md->group_count);
 	for(index = 0; index < group; index++)
 	{
-		p[index].name = strdup(groups[index].name);
-		p[index].start = groups[index].start;
-		p[index].finish = groups[index].finish;
+		p[index].name = strdup(md->groups[index].name);
+		p[index].start = md->groups[index].start;
+		p[index].finish = md->groups[index].finish;
 	}
 	
 	/* copy groups above requested group */
-	for(; index < group_count-1; index++)
+	for(; index < md->group_count-1; index++)
 	{
-		p[index].name = strdup(groups[index+1].name);
-		p[index].start = groups[index+1].start;
-		p[index].finish = groups[index+1].finish;
+		p[index].name = strdup(md->groups[index+1].name);
+		p[index].start = md->groups[index+1].start;
+		p[index].finish = md->groups[index+1].finish;
 	}
 
 	/* free all memory, then make our copy the real info */
-	clean_disc_info();
-	groups = p;
+	clean_disc_info(md);
+	md->groups = p;
 	
 	/* one less group now */
-	group_count--;
+	md->group_count--;
 	
-	write_disc_header(dev);
+	write_disc_header(dev, md);
 	return 0;
 }
 
@@ -1092,7 +1088,7 @@
 
 	return 1;
 }
-int write_disc_header(usb_dev_handle* devh)
+int write_disc_header(usb_dev_handle* devh, minidisc *md)
 {
 	int i;
 	int dash = 0;
@@ -1105,11 +1101,11 @@
 	char write_req[] = {0x00, 0x18, 0x07, 0x02, 0x20, 0x18, 0x01, 0x00, 0x00, 0x30, 0x00, 0x0a, 0x00, 0x50, 0x00, 0x00};
 	
 	/* calculate header length */
-	for(i = 0; i < group_count; i++)
+	for(i = 0; i < md->group_count; i++)
 	{
-		if(groups[i].start < 100)
+		if(md->groups[i].start < 100)
 		{
-			if(groups[i].start < 10)
+			if(md->groups[i].start < 10)
 				header_size += 1;
 			else
 				header_size += 2;
@@ -1117,11 +1113,11 @@
 		else
 			header_size += 3;
 
-		if(groups[i].finish != 0)
+		if(md->groups[i].finish != 0)
 		{
-			if(groups[i].start < 100)
+			if(md->groups[i].start < 100)
 			{
-				if(groups[i].start < 10)
+				if(md->groups[i].start < 10)
 					header_size += 1;
 				else
 					header_size += 2;
@@ -1133,7 +1129,7 @@
 		}
 
 		header_size += 3; /* room for the ; and // tokens */
-			header_size += strlen(groups[i].name);
+			header_size += strlen(md->groups[i].name);
 	}
 	header_size++;
 
@@ -1143,14 +1139,14 @@
 	memset(header, 0, header_size);
 
 	/* now generate the actual header from each group's info */
-	for(i = 0; i < group_count; i++)
+	for(i = 0; i < md->group_count; i++)
 	{
 		dash = 0; /* no dash */
 		tmp_size = 0;
 
-		if(groups[i].start < 100)
+		if(md->groups[i].start < 100)
 		{
-			if(groups[i].start < 10)
+			if(md->groups[i].start < 10)
 				tmp_size += 1;
 			else
 				tmp_size += 2;
@@ -1158,11 +1154,11 @@
 		else
 			header_size += 3;
 
-		if(groups[i].finish != 0)
+		if(md->groups[i].finish != 0)
 		{
-			if(groups[i].start < 100)
+			if(md->groups[i].start < 100)
 			{
-				if(groups[i].start < 10)
+				if(md->groups[i].start < 10)
 					tmp_size += 1;
 				else
 					tmp_size += 2;
@@ -1174,17 +1170,17 @@
 			tmp_size++; /* room for the - */
 		}
 
-		tmp_size += strlen(groups[i].name) + 3; /* name length + ; + // + NULL */
+		tmp_size += strlen(md->groups[i].name) + 3; /* name length + ; + // + NULL */
 			tmp = malloc((tmp_size + 2));
 			memset(tmp, 0, tmp_size);
 
 			/* if group starts at 0 and it isn't the disc name group */
-			if(groups[i].start == 0 && i != 0)
-				snprintf(tmp, tmp_size, ";%s//", groups[i].name);
+			if(md->groups[i].start == 0 && i != 0)
+				snprintf(tmp, tmp_size, ";%s//", md->groups[i].name);
 			else if(dash)
-				snprintf(tmp, tmp_size, "%i-%i;%s//", groups[i].start, groups[i].finish, groups[i].name);
+				snprintf(tmp, tmp_size, "%i-%i;%s//", md->groups[i].start, md->groups[i].finish, md->groups[i].name);
 			else
-				snprintf(tmp, tmp_size, "%i;%s//", groups[i].start, groups[i].name);
+				snprintf(tmp, tmp_size, "%i;%s//", md->groups[i].start, md->groups[i].name);
 
 			strcat(header, tmp);
 			strcat(header, "/");
@@ -1197,7 +1193,7 @@
 
 	memcpy(request, write_req, 16);
 	request[16] = (header_size - 1); /* new size - null */
-	request[20] = header_length; /* old size */
+	request[20] = md->header_length; /* old size */
 
 	tmp = request + 21;
 	memcpy(tmp, header, header_size);
@@ -1464,18 +1460,18 @@
 	}
 }
 
-void clean_disc_info()
+void clean_disc_info(minidisc *md)
 {
 	int i = 0;
-	for(; i < group_count; i++)
+	for(; i < md->group_count; i++)
 	{
-		free(groups[i].name);
-		groups[i].name = 0;
+		free(md->groups[i].name);
+		md->groups[i].name = 0;
 	}
 
-	free(groups);
+	free(md->groups);
 	
-	groups = 0;
+	md->groups = 0;
 }
 
 void clean_netmd(usb_dev_handle* dev)
diff -u libnetmd_orig/libnetmd.h libnetmd/libnetmd.h
--- libnetmd_orig/libnetmd.h	Sun Aug  4 14:18:39 2002
+++ libnetmd/libnetmd.h	Thu Sep  5 21:35:10 2002
@@ -45,6 +45,14 @@
 	char* name;
 } netmd_pair_t;
 
+/** stores misc data for a minidisc **/
+typedef struct {
+	int header_length;
+	struct netmd_group *groups;
+	int group_count;
+} minidisc;
+
+
 /** Global variable containing netmd_group data for each group
 	There will be enough for group_count total in the alloced memory
 */
@@ -53,12 +61,6 @@
 extern struct netmd_pair const bitrates[BITRATES + 1];
 extern struct netmd_pair const unknown_pair;
 
-/** Global varaible containing the number of groups. */
-extern int group_count;
-
-/** Global variable containing disc header length. */
-extern int header_length;
-
 /** Utility function for checking data.
   \param buf buffer to print.
   \param size length of buffer to print.
@@ -132,11 +134,12 @@
 
 /*! Sets title for the specified track.
   \param dev pointer to device returned by open_netmd
+  \param md pointer to minidisc structure
   \param group Zero based index of group your renaming (zero is disc title).
   \param title buffer holding the name.
   \return returns 0 for fail 1 for success.
 */
-int set_group_title(usb_dev_handle* dev, int group, char* title);
+int set_group_title(usb_dev_handle* dev, minidisc* md, int group, char* title);
 
 /*! Moves track around the disc.
   \param dev pointer to device returned by open_netmd
@@ -148,41 +151,49 @@
 
 /*! used internally - use the int group_count var.
   \param dev pointer to device returned by open_netmd
+  \param md pointer to minidisc structure
   \return Number of groups, counting disc title as a group (which it is)
 */
-int get_group_count(usb_dev_handle* dev);
+int get_group_count(usb_dev_handle* dev, minidisc* md);
 
 /*! sets up buffer containing group info.
   \param dev pointer to device returned by open_netmd
+  \param md pointer to minidisc structure
   \return total size of disc header
   Group[0] is disc name.  You need to make sure you call clean_disc_info before recalling
 */
-int initialize_disc_info(usb_dev_handle* dev);
+int initialize_disc_info(usb_dev_handle* dev, minidisc* md);
 
 int create_group(usb_dev_handle* devh, char* name);
 
-/*! Creates disc header out of groups and writes it to disc */
-int write_disc_header();
+/*! Creates disc header out of groups and writes it to disc
+  \param dev pointer to device returned by open_netmd
+  \param md pointer to minidisc structure
+*/
+int write_disc_header(usb_dev_handle* devh, minidisc *md);
 
 /*! Moves track into group
   \param dev pointer to device returned by open_netmd
+  \param md pointer to minidisc structure
   \param track Zero based track to add to group.
   \param group number of group (0 is title group).
 */
-int put_track_in_group(usb_dev_handle* dev, int track, int group);
+int put_track_in_group(usb_dev_handle* dev, minidisc* md, int track, int group);
 
 /*! Moves group around the disc.
   \param dev pointer to device returned by open_netmd
+  \param md pointer to minidisc structure
   \param track Zero based track to make group start at.
   \param group number of group (0 is title group).
 */
-int move_group(usb_dev_handle* dev, int track, int group);
+int move_group(usb_dev_handle* dev, minidisc* md, int track, int group);
 
 /*! Deletes group from disc (but not the tracks in it)
   \param dev pointer to device returned by open_netmd
+  \param md pointer to minidisc structure
   \param track Zero based track to delete
 */
-int delete_group(usb_dev_handle* dev, int group);
+int delete_group(usb_dev_handle* dev, minidisc* md, int group);
 
 int netmd_set_track(usb_dev_handle* dev, int track);
 int netmd_play(usb_dev_handle* dev);
@@ -201,8 +212,10 @@
 */
 int write_track(usb_dev_handle* dev, char* szFile);
 
-/*! Cleans memory allocated for the name of each group, then cleans groups pointer */
-void clean_disc_info();
+/*! Cleans memory allocated for the name of each group, then cleans groups pointer
+  \param md pointer to minidisc structure
+*/
+void clean_disc_info(minidisc* md);
 
 /*! closes the usb descriptors 
   \param dev pointer to device returned by open_netmd
@@ -221,8 +234,13 @@
 int netmd_get_current_track(usb_dev_handle* dev);
 
 /*! sets group data
- */
-void set_group_data(int group, char* name, int start, int finish);
+  \param md
+  \param group
+  \param name
+  \param start
+  \param finish
+*/
+void set_group_data(minidisc* md, int group, char* name, int start, int finish);
 
 /*! Sends a command to the MD unit and compare the result with response unless response is NULL 
   \param dev a handler to the usb device
diff -u libnetmd_orig/netmd.c libnetmd/netmd.c
--- libnetmd_orig/netmd.c	Sun Aug  4 15:14:25 2002
+++ libnetmd/netmd.c	Thu Sep  5 21:26:09 2002
@@ -1,6 +1,6 @@
 #include "libnetmd.h"
 
-void print_disc_info(usb_dev_handle* devh);
+void print_disc_info(usb_dev_handle* devh, minidisc *md);
 void print_current_track_info(usb_dev_handle* devh);
 void print_syntax();
 void import_m3u_playlist(usb_dev_handle* devh, const char *file);
@@ -11,6 +11,7 @@
 {
 	struct usb_device* netmd;
 	usb_dev_handle* devh;
+	minidisc my_minidisc, *md = &my_minidisc;
 	int i = 0;
 	int j = 0;
 	char name[16];
@@ -36,8 +37,8 @@
 	get_devname(devh, name, 16);
 	printf("%s\n", name);
 
-	initialize_disc_info(devh);
-	printf("Disc Title: %s\n\n", groups[0].name);
+	initialize_disc_info(devh, md);
+	printf("Disc Title: %s\n\n", md->groups[0].name);
 
 	if(argc > 1)
 	{
@@ -56,7 +57,7 @@
 		{
 			i = strtol(argv[2], NULL, 10);
 			j = strtol(argv[3], NULL, 10);
-			move_group(devh, j, i);
+			move_group(devh, md, j, i);
 		}
 		else if(strcmp("write", argv[1]) == 0)
 		{
@@ -73,7 +74,7 @@
 		{
 			i = strtol(argv[2], NULL, 10);
 			j = strtol(argv[3], NULL, 10);
-			if(!put_track_in_group(devh, i, j))
+			if(!put_track_in_group(devh, md, i, j))
 			{
 				printf("Something screwy happened\n");
 			}
@@ -81,15 +82,15 @@
 		else if(strcmp("retitle", argv[1]) == 0)
 		{
 			i = strtol(argv[2], NULL, 10);
-			set_group_title(devh, i, argv[3]);
+			set_group_title(devh, md, i, argv[3]);
 		}
 		else if(strcmp("writeheader", argv[1]) == 0)
 		{
 			/* edit group cause my logic fucked it up. */
 			i = strtol(argv[2], NULL, 10);
-			groups[i].start = strtol(argv[3], NULL, 10);
-			groups[i].finish = strtol(argv[4], NULL, 10);
-			write_disc_header();
+			md->groups[i].start = strtol(argv[3], NULL, 10);
+			md->groups[i].finish = strtol(argv[4], NULL, 10);
+			write_disc_header(devh, md);
 		}
 		else if(strcmp("play", argv[1]) == 0)
 		{
@@ -131,7 +132,7 @@
 		else if(strcmp("deletegroup", argv[1]) == 0)
 		{
 			i = strtol(argv[2], NULL, 10);
-			delete_group(devh, i);
+			delete_group(devh, md, i);
 		}
 		else if(strcmp("status", argv[1]) == 0) {
 			print_current_track_info(devh);	
@@ -142,14 +143,14 @@
 		}
 		else
 		{
-			print_disc_info(devh);
+			print_disc_info(devh, md);
 			print_syntax();
 		}
 	}
 	else
-		print_disc_info(devh);
+		print_disc_info(devh, md);
 
-	clean_disc_info();
+	clean_disc_info(md);
 	clean_netmd(devh);
 
 	return 0;
@@ -179,7 +180,7 @@
 
 }
 
-void print_disc_info(usb_dev_handle* devh)
+void print_disc_info(usb_dev_handle* devh, minidisc* md)
 {
 	int i = 0;
 	int size = 1;
@@ -201,9 +202,9 @@
 		}
 
 		/* Figure out which group this track is in */
-		for( group = 0, g = 1; g < group_count; g++ )
+		for( group = 0, g = 1; g < md->group_count; g++ )
 		{
-			if( (groups[g].start <= i+1) && (groups[g].finish >= i+1 ))
+			if( (md->groups[g].start <= i+1) && (md->groups[g].finish >= i+1 ))
 			{
 				group = g;
 				break;
@@ -215,7 +216,7 @@
 			lastgroup = group;
 			if( group )			/* Group 0 is 'no group' */
 			{
-				printf("Group: %s\n", groups[group].name);
+				printf("Group: %s\n", md->groups[group].name);
 			}
 		}
 		/* Indent tracks which are in a group */
@@ -249,10 +250,10 @@
 	/* XXX - This needs a rethink with the above method */
 	/* groups may not have tracks, print the rest. */
 	printf("\n--Empty Groups--\n");
-	for(group=1; group < group_count; group++)
+	for(group=1; group < md->group_count; group++)
 	{
-		if(groups[group].start == 0 && groups[group].finish == 0) {
-			printf("Group: %s\n", groups[group].name);
+		if(md->groups[group].start == 0 && md->groups[group].finish == 0) {
+			printf("Group: %s\n", md->groups[group].name);
 		}
 
 	}
